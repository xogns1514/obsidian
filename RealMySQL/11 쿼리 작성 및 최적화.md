## 11.1 쿼리 작성과 연관된 시스템 변수
MySQl 서버의 시스템 설정이 쿼리에 어떤 영향을 주는지 살펴보자. 
MySQL의 예약어에는 어떤 것이 있고, 사용할 때 주의사항
### 11.1.1 SQL 모드
### 11.1.2 영문 대소문자 구분
MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분함
→ MySQL의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.
- 윈도우에 설치된 MySQL에서는 대소문자를 구분하지 않음
- 유닉스 계열의 운영체제에서는 대소문자를 구분함
MySQL 서버가 운영체제와 관계없이 대소문자 구분의 영향을 받지 않게 하려면 MySQL 서버 설정 파일에 lower_case_table 시스템 변수를 설정하면 된다. 
- 1로 설정하면 모두 소문자로만 저장
- 기본값은 0으로 DB나 테이블명에 대해 대소문자 구분함
- 윈도우, macOS는 2로 설정할 수 있음. 저장은 대소문자를 구분하지만, 쿼리에서는 대소문자를 구분하지 않음
### 11.1.3 MySQL 예약어
테이블을 생성할 때는 항상 역따옴표로 테이블이나 칼럼의 이름을 둘러싸지 않은 상태로 생성하길 권장한다.
→ 예약어인지 아닌지 MySQL 서버가 에러로 알려주기 때문이다. 

### 11.3 MySQL 연산자와 내장 함수
### 11.3.1.2 숫자
문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 MySQL 서버가 문자열 값을 숫자 값으로 자동 변환한다.
``` SQL
SELECT * FROM tab_test WHERE string_column=10001;
```
주어진 상수값이 숫자 값인데, 비교되는 칼럼은 문자열 칼럼이다.
→ MySQL은 문자열 칼럼을 숫자로 변환해서 비교함.
→ 모든 문자열 값을 숫자로 변환해서 비교를 해야하므로 string_column에 인덱스가 있더라도 이를 이용하지 못한다.
### 11.3.1.4 불리언
BOOL이나 BOOLEAN이라는 타입이 있지만 TINYINT 타입에 대한 동의어이다.
MySQL은 TRUE 또는 FALSE 같은 불리언 값을 정수로 매핑해서 사용한다.
- FASLE: 0
- TRUE: 1 (1만 의미한다.)
### 11.3.2 MySQL 연산자
### 11.3.2.1 동등 비교
“<=>”: = 연산자와 같으며, NULL 값에 대한 비교까지 수행함.(NULL-Safe 비교 연산자)
### 11.3.2.8 BETWEEN 연산자
BETWEEN은 크다와 작다 비교를 하나로 묶어 둔 것에 가깝다. 그리고 IN 연산자는 여러 개의 동등 비교를 하나로 묶은 것과 같은 연산자라서 IN과 동등 비교 연산자는 같은 형태로 인덱스를 사용한다.
### 11.3.2.9 IN 연산자
## 11.4 SELECT
### 11.4.1 SELECT 절의 처리 순서
실행 순서를 벗어나는 쿼리가 필요하다면 서브쿼리로 작성된 인라인 뷰를 사용해야 한다. 
-> 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야 한다.
### 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
GROUP BY나 ORDER BY 절도 인덱스를 이용해 빠르게 처리할 수 있다. 어떤 요건을 갖췄을 때 인덱스를 이용할 수 있는지 살펴보자
#### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙
- WHERE 절이나 ORDER BY 또는 GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다. 
→ WHERE 조건이나 GROUP BY 또는 ORDER BY에서도 원본값을 검색하거나 정렬할 때만 B-Tree에 정렬된 인덱스를 이용한다.
- 저장하고자 하는 값의 타입에 맞춰 칼럼의 타입을 선정하고, SQL을 작성할 때는 데이터의 타입에 맞춰서 비교 조건을 사용하길 권장한다.
→ MySQL 옵티마이저가 내부적으로 타입을 변환한 후 비교 작업을 한다. 따라서 인덱스를 활용하지 못한다.

#### 11.4.2.2 WHERE 절의 인덱스 사용
WHERE 조건이 인덱스를 사용하는 방법
- 범위 결정 조건
	- WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때 얼마나 일치하는가에 따라 달라진다.
	- WHERE 조건절에 나열된 순서가 인덱스와 다르더라도 MySQL 옵티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있다. 
- 체크 조건

WHERE 절애서 각 조건이 AND로 연결되면 읽어와야 할 레코드의 건수를 줄이는 역할을 한다. 하지만 OR로 연결되면 읽어서 비교해야 할 레코드가 늘어난다.

#### 11.4.2.3 GROUP BY 절의 인덱스 사용
- GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야 한다.
- 인덱스를 구성하는 칼럼 중에서 뒤쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
- WHERE 조건절과 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못한다. 

WHERE 조건절에 앞쪽 칼럼이 동등 비교 조건으로 사용된다면, GROUP BY절에 해당 칼럼이 빠져도 인덱스를 이용한 GROUP BY가 가능할 수 있다.
```SQL
WHERE COL_1 = '상수' ... GROUP BY COL_2, COL_3
```

#### 11.3.2.3 ORDER BY 절의 인덱스 사용
ORDER BY 절의 인덱스 사용 여부는 GROUP BY의 요건과 흡사함. 
추가 조건
- 정렬되는 각 칼럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

#### 11.4.2.5 WHERE 조건과 ORDER BY, GROUP BY 절의 인덱스 사용
WHERE 절과 ORDER BY 절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 중 한 가지 방법으로만 인덱스를 이용한다.
- WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용.
	- 나머지 방식보다 훨씬 빠른 방법이다. 해당 방법으로 쿼리를 최적화하거나 인덱스를 생성
- WHERE 절만 인덱스를 이용: ORDER BY 절은 인덱스를 이용한 정렬이 불가능하며, 인덱스를 통해 검색된 결과  레코드를 FIleSort을 거쳐 정렬을 수행한다.
	- WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식
- ORDER BY절만 인덱스를 이용: ORDER BY 절은 인덱스를 이용해 처리하지만 WHERE 절은 인덱스를 이용하지 못한다.
	- ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건씩 WHER 절의 조건에 일치하는 비교

WHERE 절에서 동등 비교 조건으로 비교된 칼럼과 ORDER BY 절에 명시된 칼럼이 순서대로 빠짐없이 인덱스 칼럼의 왼쪽부터 일치해야 한다.
- WHERE 절에 동등 비교 조건으로 사용된 칼럼과 ORDER BY 절의 칼럼이 중첩되는 부분은 인덱스를 사용할 때 문제되지 않는다.

#### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용
GROUP BY와 ORDER BY 절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과 ORDER BY에 명시된 칼럼의 순서와 내용이 모두 같아야 한다.
→ GROUP BY와 ORDER BY가 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다.

#### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
WHER, ORDER BY, GROUP BY 절이 모두 포함된 쿼리가 인덱스를 사용하는지 판단하는 방법
1. WHERE 절이 인덱스를 사용할 수 있는가?
2. GROUP BY 절이 인덱스를 사용할 수 있는가?
3. GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는가?

### 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항
#### 11.4.3.1 NULL 비교
MySQL에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 쿼리에서 NULL인지 비교하려면 IS NULL(“<=>”) 연산자를 사용해야 한다.

```SQL
mysql> SELECT * FROM titles WHERE to_date IS NULL;
mysql> SELECT * FROM titles WHERE to_date ISNULL(to_date);
mysql> SELECT * FROM titles WHERE to_date ISNULL(to_date) = 1;
mysql> SELECT * FROM titles WHERE to_date ISNULL(to_date) = true;
```
첫 번째, 두 번째 쿼리는 titles 테이블의 ix_todate 인덱스를 레인지 스캔으로 사용할 수 있다. 
세 번째, 네 번째 쿼리는 인덱스나 테이블을 풀 스캔하는 형태로 처리된다.
→ NULL 비교를 할 때는 가급적 IS NULL 연산자를 사용하길 권장한다.

#### 11.4.3.2 문자열이나 숫자 비교
```SQL
mysql> SELECT * FROM employees WHERE emp_no = '10001';
mysql> SELECT * FROM employess WHERE first_name = 10001;
```
- 첫 번째는 emp_no가 숫자 타입이기 때문에, 문자열 상숫값을 숫자로 타입 변환해서 비교를 수행하므로 성능저하가 발생하지 않는다.
- 두 번째는 first_name이 문자열 칼럼이지만 비교되는 상숫값이 숫자 타입이므로, 옵티마이저는 우선순위를 가지는 숫자 타입으로 비교를 수행하려고 실행 계획을 수립한다. 칼럼의 문자열을 숫자로 변환해서 비교를 수행하므로 인덱스를 활용하지 못한다.

#### 11.4.3.3 날짜 비교
DATE 또는 DATETIME과 문자열 비교
- 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
```SQL
// DATETIME의 칼럼을 변경해서, 인덱스를 이용하지 못하는 경우
mysql> SELECT COUNT(*)
		FROM employees
		WHERE DATE_FORMAT(hire_date, '%Y-%m-%d') > '2011-07-23'
		
// 널짜 타입의 포맷을 변환하는 형태로, 인덱스를 이용하지 못하는 경우
mysql> SELECT COUNT(*)
		FROM employees
		WHERE DATE_ADD(hire_date, INTERVAL 1 YEAR) > '2011-07-23';
		
// 칼럼이 아니라 상수를 변형하는 형태를 쓰자
mysql> SELECT COUNT(*)
		FROM employees
		WHERE hire_date > DATE_SUB('2011-07-23', INTERVAL 1 YEAR);
```

DATE와 DATETIME 비교
- DATE() 함수: DATETIME 타입의 값에서 시간 부분은 버리고 날짜 부분만 변환하는 함수
- DATETIME 타입의 값을 DATE 타입으로 만들지 않고 그냥 비교하면 MySQL 서버가 DATE 타입의 값을 DATETIME으로 변환해서 같은 타입을 만든 다음 비교를 수행한다.

DATETIME과 TIMESTAP의 비교
- DATE나 DATETIME 타입의 값과 TIMESTAMP의 값을 비교할 때 타입 변환을 해주어야 인덱스를 이용한다.
- FROM_UNIXTIME(): TIMESTAMP 값을 DATETIME 타입으로 만든다
- UNIX_TIMESTAMP(): DATETIME을 TIMESTAMP로 변환

#### 11.4.3.4 Short-Circuit Evaluation
선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
- MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 “Short-Circuit Evaluiation” 방식으로 평가해서 해당 레코드를 반환해야 할지 말지 결정한다.
- WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 Short-Circuit Evaluiation과는 무관하게 MySQL 서버는 그 조건을 최우선으로 사용한다.
	- MySQL 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이 성능상 도움이 될 것이다.
	- 인덱스를 사용할 수 있는 조건은 순서가 상관없다.

### 11.4.4 DISTINCT
### 11.4.5 LIMIT n
LIMIT은 쿼리 결과에서 지정된 순서에 위치한 레코드만 가져오고자 할 때 사용된다. 
- LIMIT의 중요한 특징: 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다.
	- ex) 상위 5건까지만 정렬되면 작업을 멈춘다.
LIMIT 인자
- 1개 인자: 상위 n개의 레코드를 가져온다.
- 2개인자: (시작 위치, 오프셋)
LIMIT 주의사항
- LIMIT의 인자로 표현식이나 별도의 서브쿼리를 사용할 수 없다.
- LIMIT 조건의 페이징이 처음 몇 개 페이지 조회로 끝나지 않을 가능성이 높다면, WHERE절로 읽어야 할 위치를 찾고 그 위치에서 10개만 읽는 형태의 쿼리를 사용하는 것이 좋다.
### 11.4.6 COUNT()
- COUNT(*): *은 모든 칼럼을 가져오라는 의미가 아니라 레코드 자체를 의미하는 것이다.