
## 10.1 통계 정보
MySQL 8..0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보다 도입됐다.

### 10.1.1 테이블 및 인덱스 통계 정보
비용 기반 최적화에서 가장 중요한 것은 통계 정보다. 통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행할 수 있다. 

### 10.1.1.1 MySQL 서버의 통계 정보
MySQL 5.6 버전 부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있음.

- mysql 데이터베이스의 inndb_index_stats 테이블과 innodb_table_stats 테이블로 관리

통계 정보 갱신 이벤트

- 테이블이 새로 오픈되는 경우
- 테이블의 레코드가 대량으로 변경되는 경우
- ANALYZE TABLE 명령어 실행시
- SHOW TABLE STATUS 명령이나 SHOW INDEX FROM 명령어 실행시
- InnoDB 모니터가 활성화되는 경우
- Innodb_status_on_metadata 시스템 설정이 ON인 상태에서 SHOW TABLE STATUS 명령이 실행되는 경우

→ 시스템 설정 변수값을 OFF로 성정해 통계 정보 자동 갱신을 막을 수 있음

### 10.1.2 히스토그램

MySQL 5.7 버전 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수정도만 갖고 있었음 → 실행계획을 세우기에 정보가 부족함

8.0 버전으로 업그레이드되면서 MySQL 서버도 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활요할 수 있게 되었다.

### 10.1.2.1 히스토그램 정보 수집 및 삭제

MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리됨.

- 자동으로 수집되지 않고 ANALYZE TABLE … UPDATE HISTOGRAM 명령을 실행해 수동으로 수집 및 관리된다.

MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.

- Singleton: 칼럼값 개별로 레코드 건수를 관리하는 히스토그램, Value-Based 히스토그램 또는 도수 분포라고 불림
- Equi-Height(높이 균형 히스토그램): 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램

히스토그램은 버킷단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.

- 싱글톤 히스토그램
    - 칼럼이 가지는 값별로 버킷이 할당됨
    - 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 경우 사용된다.
- 높이 균형 히스토그램
    - 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당

### 히스토그램의 용도

히스토그램 도입 이전에도 테이블과 인덱스에 대한 통계 정보는 존재했음

- 기존 MySQL 서버가 가지고 있던 통계 정보는 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수 정도였다.
- 하지만 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다.

→ 이런 단점을 보완하기 위해 히스토그램이 도입됐다. 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위 별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.

히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측한다. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.

→ 쿼리의 성능에 상당한 영향을 미칠 수 있다.

### 10.1.2.3 히스토그램과 인덱스

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 세운다.

→ 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. 이 작업을 **인덱스 다이브**라고 표현한다.

- MySQL 8.0 서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.
- 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이므로 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다.

→ MySQL8.0 버전에서 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

하지만. 인덱스 다이브 작업은 비용이 필요하다.

### 10.1.3 코스트 모델

MySQL 서버가 쿼리를 처리하기 위한 작업

- 디스크로부터 데이터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

코스트 모델: 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업들의 비용

MySQL 5.7 이전 버전

- 작업들의 비용을 MySQL 서버 소스 코드에서 상수화해서 사용했다.

→ 하드웨어에 따라 달라질 수 있음 따라서 고정된 비용으로 적용하는 것은 최적 실행 계획 수립에 방해 요소

MySQL 5.7 버전부터 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선됐다.

→ 인덱스되지 않은 칼럼의 히스토그램이나 메모리에 상주 중인 페이지의 비율 등 비용 계산과 연관된 부분의 정보가 부족한 상태였다.

MySQL 8.0

- 칼럼의 데이터 분포를 위한 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용됨

MySQL 8.0 서버의 코스트 모델은 다음 2개 테이블에 저장돼 있는 설정값 사용

- server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리

코스트 모델에서 중요한 것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용으로 바뀌고 어떤 실행 계획들이 저비용으로 바뀌는지 파악하는 것이다.

## 10.2 실행 계획 확인

MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있다.

### 10.2.1 실행 계획 출력 포맷

MySQL 8.0 버전부터는 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.

### 10.2.2 쿼리의 실행 시간 확인

- EXPLAIN ANALYZE: 쿼리의 실행 계획과 단계별 소요된 시간 정보 확인

### 10.3 실행 계획 분석

### 10.3.1 id 칼럼

하나의 SELECT 문장은 다시 1개 이상의 하위 SELECT 문장을 포함할 수 있다.

단위(SELECT) 쿼리: SELECT 키워드 단위로 구분하는 것

- 쿼리 실행 계획에서 쿼리 문장이 단위 SELECT 쿼리로 구성되어 있다. 따라서 실행 계획의 각 레코드가 각기 다른 id 값을 지닌다.

→ 실행 계획의 id 칼럼이 테이블의 접근 순서를 의미하지 않는다.

### 10.3.2 select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼

SIMPLE

- UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리인 경우
- select_type이 SIMPLE인 쿼리는 하나만 존재한다.
- 일반적으로 제일 바깥 SELECT 쿼리의 select_type

PRIMARY

- UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
- select_type이 PRIMARY인 단위 SELECT 쿼리는 하나만 존재
- 쿼리의 제일 바깥쪽에 있는 SELECT 단위 쿼리

UNION

- UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type
- UNION의 첫 번째 단위 SELECT는 select_type이 UNION이 아니라 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.

DEPENDENT UNION

- UNION select_type과 같이 UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시된다.
- UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미

UNION RESULT
